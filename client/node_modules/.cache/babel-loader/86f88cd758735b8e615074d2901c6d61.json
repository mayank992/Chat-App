{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport { messages } from \"../constants/errorMessages\";\nimport isEqual from \"lodash.isequal\";\nvar QueryStatus;\n\n(function (QueryStatus) {\n  QueryStatus[\"loading\"] = \"loading\";\n  QueryStatus[\"error\"] = \"error\";\n  QueryStatus[\"success\"] = \"success\";\n  QueryStatus[\"idle\"] = \"idle\";\n  QueryStatus[\"fetching\"] = \"fetching\";\n})(QueryStatus || (QueryStatus = {}));\n\nexport function useQuery(queryKeys, fn) {\n  _s();\n\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    pollingInterval\n  } = options;\n  const [state, setState] = useState({\n    status: QueryStatus.idle,\n    data: null,\n    error: null\n  });\n  const isLoading = state.status === QueryStatus.loading;\n  const isError = state.status === QueryStatus.error;\n  const isSuccess = state.status === QueryStatus.success;\n  const isIdle = state.status === QueryStatus.idle;\n  const isFetching = state.status === QueryStatus.fetching;\n\n  function fetchData() {\n    // TODO - create a seperate function for refetch data\n    // TODO - create a ref for abort controller to abort any pending request before unmount\n    const controller = new AbortController();\n    const promise = fn(controller).then(response => {\n      setState(_ref => {\n        let {\n          data\n        } = _ref;\n        return {\n          data: isEqual(data, response) ? data : response,\n          status: QueryStatus.success,\n          error: null\n        };\n      });\n    }).catch(error => {\n      const errorData = error.response ? error.response.data : {\n        message: messages.NETWORK_ERROR\n      };\n      setState(prevState => ({ ...prevState,\n        status: QueryStatus.error,\n        error: errorData\n      }));\n      throw error;\n    });\n    return [controller, promise];\n  }\n\n  function refetchData() {\n    setState(prevState => ({ ...prevState,\n      status: QueryStatus.fetching\n    }));\n    return fetchData();\n  }\n\n  useEffect(() => {\n    setState(curState => ({ ...curState,\n      status: QueryStatus.loading\n    }));\n    let timerId;\n    let abortController;\n\n    (function poll() {\n      [abortController] = fetchData();\n\n      if (pollingInterval != null) {\n        timerId = window.setTimeout(poll, pollingInterval);\n      }\n    })(); // [abortController] = fetchData();\n    // if (pollingInterval != null) {\n    //   timerId = window.setInterval(() => {\n    //     let promise: Promise<any>;\n    //     // TODO - think more over case - order of request\n    //     [abortController, promise] = refetchData();\n    //     promise.catch((error) => {\n    //       clearInterval(timerId);\n    //     });\n    //   }, pollingInterval);\n    // }\n\n\n    return () => {\n      var _abortController;\n\n      // aborts the pending api call (if any) before applying new effect\n      setState({\n        status: QueryStatus.idle,\n        data: null,\n        error: null\n      });\n      (_abortController = abortController) === null || _abortController === void 0 ? void 0 : _abortController.abort();\n      clearInterval(timerId);\n    };\n  }, [...queryKeys, pollingInterval]);\n  return {\n    data: state.data,\n    error: state.error,\n    isLoading,\n    isError,\n    isSuccess,\n    isIdle,\n    isFetching,\n    refetchData\n  };\n}\n\n_s(useQuery, \"Sbjl6lAQ6UUnnFTAG1Rn1TECXvw=\");","map":{"version":3,"sources":["/Users/mayank/Desktop/assignments/Chat-App/src/hooks/useQuery.ts"],"names":["useEffect","useState","messages","isEqual","QueryStatus","useQuery","queryKeys","fn","options","pollingInterval","state","setState","status","idle","data","error","isLoading","loading","isError","isSuccess","success","isIdle","isFetching","fetching","fetchData","controller","AbortController","promise","then","response","catch","errorData","message","NETWORK_ERROR","prevState","refetchData","curState","timerId","abortController","poll","window","setTimeout","abort","clearInterval"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\";\nimport { messages } from \"../constants/errorMessages\";\nimport isEqual from \"lodash.isequal\";\n\nenum QueryStatus {\n  loading = \"loading\",\n  error = \"error\",\n  success = \"success\",\n  idle = \"idle\",\n  fetching = \"fetching\",\n}\n\ntype QueryOptions = {\n  pollingInterval?: number;\n};\n\nexport function useQuery<T>(\n  queryKeys: any[],\n  fn: (controller: AbortController) => Promise<any>,\n  options: QueryOptions = {}\n) {\n  const { pollingInterval } = options;\n  const [state, setState] = useState<{\n    status: QueryStatus;\n    data: T | null;\n    error: any;\n  }>({\n    status: QueryStatus.idle,\n    data: null,\n    error: null,\n  });\n\n  const isLoading = state.status === QueryStatus.loading;\n  const isError = state.status === QueryStatus.error;\n  const isSuccess = state.status === QueryStatus.success;\n  const isIdle = state.status === QueryStatus.idle;\n  const isFetching = state.status === QueryStatus.fetching;\n\n  function fetchData(): [AbortController, Promise<any>] {\n    // TODO - create a seperate function for refetch data\n    // TODO - create a ref for abort controller to abort any pending request before unmount\n    const controller = new AbortController();\n\n    const promise = fn(controller)\n      .then((response) => {\n        setState(({ data }) => {\n          return {\n            data: isEqual(data, response) ? data : response,\n            status: QueryStatus.success,\n            error: null,\n          };\n        });\n      })\n      .catch((error) => {\n        const errorData = error.response\n          ? error.response.data\n          : { message: messages.NETWORK_ERROR };\n\n        setState((prevState) => ({\n          ...prevState,\n          status: QueryStatus.error,\n          error: errorData,\n        }));\n        throw error;\n      });\n\n    return [controller, promise];\n  }\n\n  function refetchData() {\n    setState((prevState) => ({\n      ...prevState,\n      status: QueryStatus.fetching,\n    }));\n\n    return fetchData();\n  }\n\n  useEffect(() => {\n    setState((curState) => ({ ...curState, status: QueryStatus.loading }));\n\n    let timerId: number | undefined;\n    let abortController: AbortController;\n\n    (function poll() {\n      [abortController] = fetchData();\n\n      if (pollingInterval != null) {\n        timerId = window.setTimeout(poll, pollingInterval);\n      }\n    })();\n\n    // [abortController] = fetchData();\n\n    // if (pollingInterval != null) {\n    //   timerId = window.setInterval(() => {\n    //     let promise: Promise<any>;\n    //     // TODO - think more over case - order of request\n\n    //     [abortController, promise] = refetchData();\n\n    //     promise.catch((error) => {\n    //       clearInterval(timerId);\n    //     });\n    //   }, pollingInterval);\n    // }\n\n    return () => {\n      // aborts the pending api call (if any) before applying new effect\n      setState({ status: QueryStatus.idle, data: null, error: null });\n      abortController?.abort();\n      clearInterval(timerId);\n    };\n  }, [...queryKeys, pollingInterval]);\n\n  return {\n    data: state.data,\n    error: state.error,\n    isLoading,\n    isError,\n    isSuccess,\n    isIdle,\n    isFetching,\n    refetchData,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}